;;;; | Simple Finkel REPL.
;;;;
;;;; This implementation uses two threads: one for reading and printing,
;;;; and another for evaluating and modifying the FnkEnv. Using `MVar'
;;;; containing `Code' to communicate between the threads. This design
;;;; shall be easier to support reading forms from other sources than
;;;; line oriented user input, e.g. network sockets.

(:require Finkel.Core)

(defmodule Finkel.Tool.Repl
  (export replMain repl-env)
  (import-when [:compile]
    ;; finkel-core
    (Finkel.Prelude)

    ;; Internal
    (Finkel.Tool.Repl.Macro))
  (import
   ;; base
   (Control.Monad (mplus))
   (Control.Monad.IO.Class ((MonadIO ..)))
   (Data.List (isPrefixOf))
   (System.Console.GetOpt
    ((ArgDescr ..) (ArgOrder ..) (OptDescr ..) getOpt usageInfo))
   (System.Environment (getProgName))

   ;; finkel-kernel
   (Language.Finkel.Fnk ((FnkEnv ..) EnvMacros makeEnvMacros mergeMacros))
   (Language.Finkel.SpecialForms (defaultFnkEnv specialForms))

   ;; finkel-core
   (Finkel.Core)

   ;; Internal
   (Finkel.Tool.CLI)
   (Finkel.Tool.Repl.Macro)
   (Finkel.Tool.Repl.Loop)
   (Finkel.Tool.Repl.Types)))



;;; Exported

(defn (:: replMain (=> (CLI m) (-> [String] (m ()))))
  "Main entry point function for REPL."
  [args]
  (let ((= (, repl-opts ghc-opts) (partition-repl-args args))
        (= initial-option (make-initial-option ghc-opts)))
    (case (getOpt Permute descrs repl-opts)
      (, o _other []) (act (foldl (flip id) initial-option o))
      (, _ _ es) (print-errors es))))

(defn (:: repl-env FnkEnv)
  "Environment value used by the Finkel REPL."
  (let ((= macros (mergeMacros specialForms replMacros)))
    (defaultFnkEnv {envContextModules ["Prelude"]
                    envMacros macros
                    envDefaultMacros macros
                    envQualifyQuotePrimitives True})))


;;; Internal

;;; Note: [REPL options, ghc options, and RTS options]
;;; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;;;
;;; REPL sub command supporst options specific to the REPL sub command, options
;;; to update `DynFlags' in GhcMonad, and options for RTS. To accompilish
;;; support of these three kind of options, the command line argument handling
;;; work starts with filtering out the REPL specific options with manually
;;; separating the long options defined with `OptDescr' from
;;; `System.Console.GetOpts' module. Then, the rest of the arguments are treated
;;; as ghc options and RTS options.
;;;
;;; Note that, in the C source code of the `rts' package, command line arguments
;;; after `--' are passed to the callee program (see: "rts/RtsFlags.c" in the
;;; ghc source code for detail). Once the command line parser for REPL options
;;; tried to separate ghc options from REPL specific options with `--', however
;;; this approach did not work well when considering RTS options.

(data ReplMode
  Help
  Run)

(data ReplOption
  (ReplOption {repl-mode ReplMode
               repl-listen-port (Maybe Int)
               repl-input-path (Maybe FilePath)
               repl-prompt (Maybe String)
               repl-ghc-options [String]}))

(defn (:: make-initial-option (-> [String] ReplOption))
  [ghc-options]
  (ReplOption {repl-mode Run
               repl-listen-port Nothing
               repl-input-path Nothing
               repl-prompt Nothing
               repl-ghc-options ghc-options}))

(defn (:: partition-repl-args (-> [String] (, [String] [String])))
  "Separate REPL specific options from other (ghc and RTS) options."
  (let ((= partition-arg x (, rs gs)
          (if (any (in-long-opt x) descrs)
              (, (: x rs) gs)
              (, rs (: x gs))))
        (= in-long-opt x (Option _ ls _ _)
          (any (. (flip isPrefixOf x) (++ "--")) ls)))
    (foldr partition-arg (, [] []))))

(defn (:: descrs [OptDescr (-> ReplOption ReplOption)])
  [(Option [] ["help"]
           (NoArg (\ o (o {repl-mode Help})))
           "Show this help and exit")
   (Option [] ["listen"]
           (OptArg (\ mb-port o
                     (let ((= port
                             (mplus (fmap read mb-port)
                                    (Just 50321))))
                       (o {repl-mode Run
                           repl-listen-port port})))
                   "PORT")
           "Listen to port (default: 50321)")
   (Option [] ["file"]
           (ReqArg (\ file o (o {repl-input-path (Just file)}))
                   "FILE")
           "File to get input from")
   (Option [] ["prompt"]
           (ReqArg (\ str o (o {repl-prompt (Just str)}))
                   "TEXT")
           "Prompt for input (default: '> ')")])

(defn (:: act (=> (CLI m) (-> ReplOption (m ()))))
  [ro]
  (case (repl-mode ro)
    Help print-usage
    Run (liftIO (start-repl (repl-ghc-options ro)
                            (repl-input-path ro)
                            (repl-listen-port ro)
                            repl-env
                            (maybe mempty (\ p (mempty {prompt-string p}))
                                   (repl-prompt ro))))))

(defn (:: print-errors (=> (CLI m) (-> [String] (m ()))))
  [errs]
  (do (putString (concat errs))
      print-usage
      (exitWith (ExitFailure 1))))

(defn (:: print-usage (=> (CLI m) (m ())))
  (do (<- name (liftIO getProgName))
      (putString
       (unlines
        [(concat ["USAGE: " name " repl [OPTIONS]"])
         ""
         "Start interactive REPL."
         ""
         (usageInfo "OPTIONS:\n" descrs)
         "  Other options are passed to ghc."]))))

(defn (:: replMacros EnvMacros)
  "Default macros imported in REPL. These macros always get imported after
loading compiled modules."
  (macrolet ((the-macros ()
               `[,@(map (\ mac `(, ,mac ,(qSymbol mac)))
                        (++ (exported-macros Finkel.Core)
                            (exported-macros Finkel.Tool.Repl.Macro)))]))
    (makeEnvMacros (the-macros))))
