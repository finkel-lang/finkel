;;;; Macros used in REPL.

;;; This module contains macros accessible only from REPL. Main purpose
;;; of using macros for REPL is to access runtime value of
;;; `FnkEnv'. Macro body can contain codes accessing `FnkEnv', and then
;;; the code could be invoked from REPL via evaluating the typed in
;;; forms.

(:require Finkel.Core)

(defmodule Finkel.Tool.Repl.Macro
  (export repl-macro)
  (import-when [:compile]
    ;; finkel-core
    (Finkel.Prelude))
  (import
   ;; base
   (Control.Exception ((Exception ..) (SomeException ..) try))
   (Control.Monad (filterM unless void when))
   (Control.Monad.IO.Class ((MonadIO ..)))
   (Data.Function (on))
   (Data.List
    (find intercalate intersperse isPrefixOf partition sortBy))
   (Data.Maybe (catMaybes))
   (Text.Printf (printf))
   (Text.Read (readMaybe))

   ;; directory
   (System.Directory
    (getCurrentDirectory getHomeDirectory setCurrentDirectory))

   ;; filepath
   (System.FilePath (normalise))

   ;; ghc
   (BasicTypes (Fixity (StringLiteral ..) defaultFixity))
   (DynFlags ((DynFlags ..) (GhcMode ..) (HasDynFlags ..) (HscTarget ..)
              (Language ..) (PackageFlag ..) (GeneralFlag ..)
              defaultDynFlags fFlags flagSpecFlag flagSpecName gopt
              isObjectTarget lang_set parseDynamicFlagsCmdLine thisPackage
              xFlags xopt wopt wWarningFlags))
   (ErrUtils (pprErrMsgBagWithLoc))
   (Exception (gcatch gbracket))
   (FamInstEnv (FamInst pprFamInst))
   (FastString (FastString fsLit unpackFS))
   (Finder (flushFinderCaches uncacheModule))
   (GHC ((ModuleInfo) findModule getBindings getModSummary getModuleGraph
         getModuleInfo getPrintUnqual getTargets isLoaded lookupName
         lookupModule modInfoExports setSessionDynFlags setTargets
         workingDirectoryChanged))
   (GhcMake ((LoadHowMuch ..)))
   (GhcMonad ((GhcMonad ..) getSessionDynFlags modifySession))
   (HscMain (newHscEnv))
   (HscTypes ((HscEnv ..) (InteractiveContext ..) (InteractiveImport ..)
              (ModSummary ..) ModuleGraph (Target ..) (TargetId ..)
              emptyInteractiveContext handleFlagWarnings ms_mod_name pprHPT
              pprTarget srcErrorMessages tyThingParent_maybe))
   (IfaceSyn (showToHeader))
   (InstEnv (ClsInst pprInstance))
   (InteractiveEval (abandonAll getContext getInfo moduleIsInterpreted
                                parseName setContext showModule))
   (Linker (initDynLinker showLinkerState unload))
   (Module ((InstalledUnitId ..) (Module ..) ModuleName
            componentIdToInstalledUnitId mainUnitId mkModuleName mkModuleNameFS
            moduleNameString toInstalledUnitId))
   (Name (getName nameIsFromExternalPackage nameModule nameOccName nameSrcSpan
                  pprInfixName))
   (NameSet (elemNameSet mkNameSet))
   (Outputable (SDoc $$ <+> <> empty dcolon hsep nest ppr sep
                     showPpr showSDoc showSDocForUser text vcat))
   (Packages ((PackageName ..) lookupPackageName))
   (PprTyThing (pprTyThing pprTyThingInContextLoc pprTypeForUser))
   (SrcLoc (getLoc isGoodSrcSpan mkGeneralLocated noLoc unLoc))
   (TyCoRep ((TyThing ..)))
   (Util (looksLikeModuleName))

   (qualified GhcMake as GhcMake)

   ;; ghci
   (Debugger (pprTypeAndContents))

   ;; process
   (System.Process (system))

   ;; finkel-kernel
   (Language.Finkel)
   (Language.Finkel.Eval (evalExprType evalTypeKind))
   (Language.Finkel.Form (mkLocatedForm))
   (Language.Finkel.Make (buildHsSyn make))
   (Language.Finkel.Fnk
    ((FnkEnv ..) getFnkEnv macroNames modifyFnkEnv putFnkEnv setDynFlags
     setFnkVerbosity))
   (Language.Finkel.Syntax (parseExpr parseType))
   (Language.Finkel.TargetSource (asModuleName))

   ;; finkel-core
   (Finkel.Core.Functions)))

;;; Extra imports

(cond-expand
  [(<= 810 :ghc)
   (:begin
     (import GHC.Hs.ImpExp ((ImportDecl ..) simpleImportDecl))
     (import DynFlags (settings)))]
  [otherwise
   (import HsImpExp ((ImportDecl ..) simpleImportDecl))])

(cond-expand
  [(<= 804 :ghc)
   (:begin
     (import Prelude hiding (<>))
     (import qualified HscTypes as HscTypes))]
  [otherwise
   (:begin)])

(cond-expand
  [(<= 810 :ghc)
   (:begin
     (import GHCi (iservCmd))
     (import GHCi.Message ((Message ..))))]
  [otherwise
   (:begin)])



;;; Types

(type ReplAction (-> [Code] (Fnk Code)))

(data ReplCmd
  (ReplCmd {rc-name String
            rc-args [String]
            rc-action ReplAction
            rc-help String}))


;;; Auxiliary functions

(defn (:: gen-default-dflags (-> DynFlags DynFlags))
  [flg]
  (cond-expand
    [(<= 810 :ghc)
     (defaultDynFlags (settings flg) (llvmConfig flg))]
    [(<= 806 :ghc)
     (defaultDynFlags (settings flg) (, (llvmTargets flg) (llvmPasses flg)))]
    [(<= 804 :ghc)
     (defaultDynFlags (settings flg) (llvmTargets flg))]
    [otherwise
     (defaultDynFlags (settings flg))]))

(defn (:: graph-to-summaries (-> ModuleGraph [ModSummary]))
  (cond-expand
    [(<= 804 :ghc)
      HscTypes.mgModSummaries]
    [otherwise
     id]))

(defn (:: show-linker-state (-> HscEnv (IO ())))
  [hsc-env]
  (cond-expand
    [(<= 810 :ghc)
     (showLinkerState (hsc-dynLinker hsc-env) (hsc-dflags hsc-env))]
    [otherwise
     (showLinkerState (hsc-dflags hsc-env))]))

(defn (:: rts-revert-cafs (Fnk ()))
  (cond-expand
    [(<= 810 :ghc)
     (do (<- hsc-env getSession)
         (liftIO (iservCmd hsc-env RtsRevertCAFs)))]
    [(== 808 :ghc)
     (liftIO (rts-revert-cafs-ffi))]
    [otherwise
     (return ())]))

(cond-expand
  [(== 808 :ghc)
   (foreign import ccall "revertCAFs" (:: rts-revert-cafs-ffi (IO ())))]
  [otherwise
   (:begin)])

(defn (:: mk-ii (-> ModuleName InteractiveImport))
  (. IIDecl simpleImportDecl))

(defn (:: mk-ii-fs (-> FastString InteractiveImport))
  (. mk-ii mkModuleNameFS))

(defn (:: mk-ii-str (-> String InteractiveImport))
  (. mk-ii-fs fsLit))

(defn (:: code-to-mb-string (-> Code (Maybe String)))
  (. (fmap unpackFS) code-to-mb-fs))

(defn (:: code-to-mb-fs (-> Code (Maybe FastString)))
  [code]
  (case (unCode code)
    (Atom (ASymbol s)) (Just s)
    (Atom (AString _ s)) (Just s)
    _ Nothing))

(defn (:: located-list (-> [Code] Code))
  [xs]
  (case xs
    [] nil
    _  (LForm (L (getLoc (mkLocatedForm xs)) (List xs)))))

(defn (:: show-sdoc-for-user-m (-> SDoc (Fnk String)))
  [sdoc]
  (do (<- dflags getDynFlags)
      (<- unqual getPrintUnqual)
      (return (showSDocForUser dflags unqual sdoc))))

(defn (:: invalid-form (-> String [Code] (Fnk a)))
  [label forms]
  (let ((= form (car (located-list forms)))
        (= msg (concat [label ": invalid form `" (show form) "'"])))
    (finkelSrcError form msg)))

(defn (:: compile-module (-> String (Fnk Code)))
  [str]
  (where (gbracket acquire cleanup work)
    (= acquire
      (do (<- dflags getDynFlags)
          (<- fnk-env getFnkEnv)
          (return (, dflags fnk-env))))
    (= cleanup (, dflags fnk-env)
      (do (setDynFlags dflags)
          (putFnkEnv fnk-env)))
    (= work (, dflags fnk-env)
      (do (putFnkEnv (fnk-env {envQualifyQuotePrimitives False}))
          (let ((= onTheREPL (mkGeneralLocated "on the REPL"))
                (= no-link True)
                (= force-recomp (gopt Opt-ForceRecomp dflags))))
          (make [(, (onTheREPL str) Nothing)] no-link force-recomp Nothing)

          ;; As done in `GHCi.UI', reverting CAFs on load.
          rts-revert-cafs

          (return '(:begin))))))

(defn (:: compile-and-import (-> FilePath (Fnk Code)))
  [path]
  ;; As done in ghci, adding `IIModule' if the module is interpreted as
  ;; bytecode, `IIDecl' otherwise. Safe Haskell setting in DynFlags is
  ;; ignored at the moment.
  (do (<- fnk-env getFnkEnv)
      (<- _ (compile-module path))
      (let ((= mods (envContextModules fnk-env))
            (= mname0 (asModuleName path))
            (= mname1 (| ((null mname0) "Main")
                         (otherwise     mname0)))
            (= mname2 (mkModuleNameFS (fsLit mname1)))
            (= imps0 (map mk-ii-str mods))))
      (<- mdl (getModSummary mname2))
      (<- is-interp (moduleIsInterpreted (ms-mod mdl)))
      (let ((= me (| (is-interp (IIModule mname2))
                     (otherwise (mk-ii mname2))))))
      (setContext (: me imps0))
      (return '(:begin))))

(defn (:: adjust-current-target
        (-> FilePath [InteractiveImport] (Fnk [InteractiveImport])))
  "Adjust current IIModule target to IIDecl if current HscTarget is
object code."
  [path imports]
  (do (<- dflags getDynFlags)
      (let ((= current-module-name (mkModuleName (asModuleName path)))
            (= iimodule-to-iidecl ii
              (case ii
                (IIModule mname) (| ((== mname current-module-name)
                                     (mk-ii mname)))
                _                ii))
            (= iidecl-to-iimodule ii
              (case ii
                (IIDecl idecl) (| ((== (unLoc (ideclName idecl))
                                       current-module-name)
                                   (IIModule current-module-name)))
                _              ii))
            (= ii-fn (if (isObjectTarget (hscTarget dflags))
                         iimodule-to-iidecl
                         iidecl-to-iimodule))))
      (return (map ii-fn imports))))

(defn (:: env-context-on-exception (-> (Fnk a) (Fnk ())))
  [action]
  (gcatch
   (void action)
   (\ e
     (do (let ((= print-se se
                 (do (<- dflags getSessionDynFlags)
                     (liftIO
                      (putStr (unlines
                               (map (showSDoc dflags)
                                    (pprErrMsgBagWithLoc
                                     (srcErrorMessages se))))))))))
         (maybe (liftIO (print e)) print-se (fromException e))
         (<- mods (fmap envContextModules getFnkEnv))
         (setContext (map mk-ii-str mods))))))

(defn (:: browse-module (-> Module ModuleInfo (Fnk Code)))
  "Simplified version of `GHCi.UI.browseModule'."
  [mdl mod-info]
  (do (let ((= names (modInfoExports mod-info))
            (= sorted-names
              (++ (loc-sort local) (occ-sort external)))
            (= (, local external)
              (partition (. (== mdl) nameModule) names))
            (= occ-sort (sortBy (on compare nameOccName)))
            (= loc-sort ns
              (| ((<- (: n _) ns) (isGoodSrcSpan (nameSrcSpan n))
                  (sortBy (on compare nameSrcSpan) ns))
                 (otherwise (occ-sort ns))))
            (= pretty
              (pprTyThing showToHeader))))
      (<- mb-things (mapM lookupName sorted-names))
      (let ((= things (catMaybes mb-things))
            (= prettyThings (map pretty things))))
      (<- str (show-sdoc-for-user-m (vcat prettyThings)))
      (return `(System.IO.putStrLn ,str))))

(defn (:: expand-with (-> String (-> Code (Fnk Code)) ReplAction))
  [label f forms]
  (case forms
    [] (return '(:begin))
    [expr] (>>= (f expr) (\ x (return `(System.IO.print ',x))))
    _ (invalid-form label forms)))

;;; Mostly translated from `GHCi.UI.infoThing'.
(defn (:: info-name (-> Code (Fnk Code)))
  [thing]
  (do (<- sdoc (info-thing True (show thing)))
      (<- str (show-sdoc-for-user-m sdoc))
      (return `(System.IO.putStrLn ,str))))

(defn (:: info-thing (-> Bool String (Fnk SDoc)))
  [all-info str]
  (where (do (<- names (parseName str))
             (<- mb_stuffs (mapM (getInfo all-info) names))
             (let ((= filtered (filter-out-children
                                child-filter
                                (catMaybes mb_stuffs)))))
             (return
              (vcat (intersperse (text "") (map ppr-info filtered)))))
    (cond-expand
      [(<= 804 :ghc)
       (:begin
         (defn child-filter [(, a _ _ _ _)] a)
         (defn ppr-info [(, thing fixity cls fam _)]
           (__ppr-info thing fixity cls fam)))]
      [otherwise
       (:begin
         (defn child-filter [(, a _ _ _)] a)
         (defn ppr-info [(, thing fixity cls fam)]
           (__ppr-info thing fixity cls fam)))])))

(defn (:: __ppr-info (-> TyThing Fixity [ClsInst] [FamInst] SDoc))
  [thing fixity cls fam]
  (let ((= show-fixity
          (if (== fixity defaultFixity)
              empty
              (<+> (ppr fixity) (pprInfixName (getName thing))))))
    ($$ (pprTyThingInContextLoc thing)
        show-fixity
        (vcat (map pprInstance cls))
        (vcat (map pprFamInst fam)))))

(defn (:: filter-out-children (-> (-> a TyThing) [a] [a]))
  [get-thing xs]
  (let ((= all-names (mkNameSet (map (. getName get-thing) xs)))
        (= has-parent x
          (case (tyThingParent-maybe (get-thing x))
            (Just p) (elemNameSet (getName p) all-names)
            _ False)))
    (filter (. not has-parent) xs)))

(defn (:: clear-all-targets (=> (GhcMonad m) (m ())))
  (do (setTargets [])
      (void (GhcMake.load LoadAllTargets))))

;;; From `GhcMake.discardIC'.
(defn (:: discard-ic (-> HscEnv HscEnv))
  [hsc-env]
  (let ((= empty-ic (emptyInteractiveContext dflags))
        (= new-ic-monad (keep-external-name ic_monad))
        (= old-ic (hsc_IC hsc-env))
        (= dflags (hsc_dflags hsc-env))
        (= keep-external-name ic-name
          (where (| ((nameIsFromExternalPackage this-pkg old-name)
                     old-name)
                    (otherwise
                     (ic-name empty-ic)))
            (= this-pkg (thisPackage dflags))
            (= old-name (ic-name old-ic)))))
    (hsc-env {hsc_IC (empty-ic {ic_monad new-ic-monad})})))



;;; Functions for show command

(defn (:: show-bindings (Fnk Code))
  (where (do (<- bs getBindings)
             (<- docs (mapM make-doc (reverse bs)))
             (<- str (show-sdoc-for-user-m (vcat docs)))
             (return `(System.IO.putStrLn ,str)))
    (:: make-doc (-> TyThing (Fnk SDoc)))
    (defn make-doc [tt]
      (case tt
        (AnId i) (pprTypeAndContents i)
        _ (do (<- mb-stuff (getInfo False (getName tt)))
              (return (maybe (text "") ppr-tt mb-stuff)))))
    (cond-expand
      [(<= 804 :ghc)
       (defn ppr-tt [(, thing _ _ _ _)]
         (pprTyThing showToHeader thing))]
      [otherwise
       (defn ppr-tt [(, thing _ _ _)]
         (pprTyThing showToHeader thing))])))

(defn (:: show-context (Fnk Code))
  (where (do (<- context getContext)
             (<- dflags getSessionDynFlags)
             (return `(System.IO.putStr ,(result dflags context))))
    (= result dflags context
      (unlines (: "; context" (map (context-string dflags) context))))
    (= context-string dflags ctx
      (case ctx
        (IIDecl d) (++ ";  IIDecl: " (showSDoc dflags (ppr d)))
        (IIModule m) (++ ";  IIModule: " (moduleNameString m))))))

(defn (:: show-dflags (Fnk Code))
  (do (<- dflags getDynFlags)
      (let ((= ss
              ["; dflags:"
               (++ ";  ghcLink: " (show (ghcLink dflags)))
               (++ ";  ghcMode: " (showGhcMode (ghcMode dflags)))
               (++ ";  hscTarget: " (show (hscTarget dflags)))
               (++ ";  objectDir: " (show (objectDir dflags)))
               (++ ";  thisInstalledUnitId: "
                   (showPpr dflags (thisInstalledUnitId dflags)))
               (++ ";  forceRecomp: "
                   (show (gopt Opt-ForceRecomp dflags)))])
            (= showGhcMode m
              (case m
                CompManager "CompManager"
                OneShot     "OneShot"
                MkDepend    "MkDepend"))))
      (return `(System.IO.putStr ,(unlines ss)))))

(defn (:: show-hpt (Fnk Code))
  "Show home package table."
  (do (<- hsc-env getSession)
      (<- str0 (show-sdoc-for-user-m (pprHPT (hsc-HPT hsc-env))))
      (let ((= str1 (if (null str0)
                        "show: no home package table found"
                        str0))))
      (return `(System.IO.putStrLn ,str1))))

;;; Mostly taken from `GHCi.UI.showLanguages''.
(defn (:: show-language (-> Bool (Fnk Code)))
  [show-all]
  (do (<- dflags getDynFlags)
      (let ((= setting test flag
              (where (| (quiet     empty)
                        (is-on     (<> (text "-X") (text name)))
                        (otherwise (<> (text "-XNo") (text name))))
                (= name (flagSpecName flag))
                (= f (flagSpecFlag flag))
                (= is-on (test f dflags))
                (= quiet (&& (not show-all)
                             (== (test f default-dflags) is-on)))))

            (= default-dflags
              (lang_set (gen-default-dflags dflags)
                        (case (language dflags)
                          Nothing (Just Haskell2010)
                          other   other)))))
      (<- str
        (show-sdoc-for-user-m
         (vcat [(<> (text "base language is: ")
                    (case (language dflags)
                      Nothing (text "Haskell2010")
                      (Just Haskell98) (text "Haskell98")
                      (Just Haskell2010) (text "Haskell2010")))
                ($$ (if show-all
                        (text "all active language options:")
                        (text "with the following modifiers:"))
                    (nest 2 (vcat (map (setting xopt) xFlags))))])))
      (return `(System.IO.putStrLn ,str))))

(defn (:: show-linker (Fnk Code))
  ;; XXX: `Linker.showLinkerState' reads from `v_PersistentLinkerState',
  ;; which is not exposed from the module its defined ... not sure how
  ;; to get resulting output as `String' other than redirecting output
  ;; to stdout.
  (do (<- hsc-env getSession)
      (liftIO (do (initDynLinker hsc-env)
                  (show-linker-state hsc-env)))
      (return '(:begin))))

(defn (:: show-macros (Fnk Code))
  (do (<- macros (fmap envMacros getFnkEnv))
      (let ((= macro-strings
              (unlines
               (: "; macros: "
                  (map (++ ";  ") (macroNames macros)))))))
      (return `(System.IO.putStr ,macro-strings))))

(defn (:: show-modules (Fnk Code))
  (do (<- graph0 getModuleGraph)
      (let ((= graph1 (graph-to-summaries graph0))))
      (<- graph2 (filterM (. isLoaded ms_mod_name) graph1))
      (<- mods (mapM showModule graph2))
      (return `(System.IO.putStr ,(unlines mods)))))

(defn (:: show-options (-> Bool (Fnk Code)))
  [show-all]
  (do (<- dflags getDynFlags)
      (let ((= setting prefix no-prefix test flag
              (where (| (quiet     empty)
                        (is-on     (<> (text prefix) (text name)))
                        (otherwise (<> (text no-prefix) (text name))))
                (= name (flagSpecName flag))
                (= f (flagSpecFlag flag))
                (= is-on (test f dflags))
                (= quiet (&& (not show-all)
                             (== (test f default-dflags) is-on)))))
            (= default-dflags
              (gen-default-dflags dflags))
            (= (, ghciFlags others)
              (partition (\ f (elem (flagSpecFlag f) flgs)) fFlags))
            (= flgs
              [Opt_PrintExplicitForalls
               Opt_PrintExplicitKinds
               Opt_PrintBindResult
               Opt_BreakOnException
               Opt_BreakOnError
               Opt_PrintEvldWithShow])
            (= sdocs
              [($$ (text "REPL specific dynamic flag settings:")
                   (nest 2 (vcat (map (setting "-f" "-fno-" gopt)
                                      ghciFlags))))
               ($$ (text "other dynamic, non-language, flag settings:")
                   (nest 2 (vcat (map (setting "-f" "-fno-" gopt)
                                      others))))
               ($$ (text "warning settings:")
                   (nest 2 (vcat (map (setting "-W" "-Wno-" wopt)
                                      wWarningFlags))))])))
      (<- printLang (show-language show-all))
      (let ((= printOthers
              `(Data.Foldable.mapM_
                System.IO.putStrLn
                ,(map (showSDoc dflags) sdocs)))))
      (return `(>> ,printLang ,printOthers))))

(defn (:: show-packages (Fnk Code))
  (do (<- dflags getDynFlags)
      (let ((= pr (++ ";   "))
            (= pr-flag flag
              (case flag
                (ExposePackage n _ _) (pr n)
                (HidePackage n) (pr (++ "hiding " n))))
            (= pkgs
              (: "; packages" (map pr-flag (packageFlags dflags))))))
      (return `(System.IO.putStr ,(unlines pkgs)))))

(defn (:: show-paths (Fnk Code))
  (do (<- dflags getDynFlags)
      (<- cwd (liftIO getCurrentDirectory))
      (let ((= ipaths (importPaths dflags))
            (= result
              (unlines
               (concat
                [["; current working directory:"
                  (++ ";   " cwd)
                  "; module import search paths:"]
                 (if (null ipaths)
                     [";    none"]
                     (map (++ ";    ") ipaths))])))))
      (return `(System.IO.putStr ,result))))

(defn (:: show-targets (Fnk Code))
  (do (<- hsc-env getSession)
      (<- strs (mapM (. show-sdoc-for-user-m pprTarget)
                     (hsc-targets hsc-env)))
      (let ((= ts (if (null strs)
                      "none"
                      (unwords strs)))))
      (return `(System.IO.putStrLn (++ "; targets: " ,ts)))))


;;; REPL commands

(defn (:: help-cmd ReplAction)
  [_form]
  (return
   `(System.IO.putStrLn ,(++ "DESCRIPTION: \n\
\\n\
\  REPL meta macro, ARGS varies per COMMAND.\n\
\\n\
\COMMANDS:\n\
\\n" (unlines
      (map (\ rc
             (let ((= pre (unwords (: (rc-name rc) (rc-args rc)))))
               (concat
                ["  ," (printf "%-14s" pre) " - " (rc-help rc)])))
           commands))))))

(defn (:: system-cmd ReplAction)
  "Invoke system command."
  [forms]
  (do (<- _ecode (liftIO (system (intercalate " " (map show forms)))))
      (return '(:begin))))

;;; Mostly taken from `GHCi.UI.guessCurrentModule'.
(defn (:: guess-current-module (-> Code (Fnk Module)))
  [form]
  (case-do getContext
    (: (IIModule m) _) (findModule m Nothing)
    (: (IIDecl d) _)   (findModule (unLoc (ideclName d))
                                   (fmap sl-fs (ideclPkgQual d)))
    _ (finkelSrcError form "browse: no current module")))

;;; Mostly taken from `GHCi.UI.browseCmd'.
(defn (:: browse-cmd ReplAction)
  [forms]
  (let ((= go mb-name
          (case mb-name
            (Just name) (| ((looksLikeModuleName name)
                            (>>= (lookupModule (mkModuleName name) Nothing)
                                 go')))
            _ (>>= (guess-current-module (located-list forms)) go')))
        (= go' mdl
          (case-do (getModuleInfo mdl)
            (Just mod-info) (browse-module mdl mod-info)
            Nothing (do (let ((= mname (moduleName mdl))
                              (= str (moduleNameString mname))
                              (= msg (++ "unknown module: " str))))
                        (return `(System.IO.putStrLn ,msg))))))
    (case (map unCode forms)
      [(Atom (ASymbol sym))] (go (Just (unpackFS sym)))
      [] (go Nothing)
      _ (invalid-form "browse" forms))))

(defn (:: expand-path (=> (MonadIO m) (-> FilePath (m FilePath))))
  (let ((:: try-getHomeDirectory (IO (Either SomeException FilePath)))
        (= try-getHomeDirectory (try getHomeDirectory))
        (= go path
          (case path
            (: #'~ rest) (case-do try-getHomeDirectory
                           (Right home) (pure (normalise
                                               (++ home (: #'/ rest))))
                           (Left _) (pure path))
            _ (return path))))
    (. liftIO go)))

;;; From `GHCi.UI.changeDirectory'.
(defn (:: cd-cmd ReplAction)
  "Function to change current directory."
  [forms]
  (let ((= work dir0
          (do (<- graph getModuleGraph)
              (<- mods (fmap envContextModules getFnkEnv))
              (when ($ not null graph-to-summaries graph)
                (liftIO (putStrLn warn-unloading)))
              clear-all-targets
              (setContext (map mk-ii-str mods))
              workingDirectoryChanged
              (liftIO (do (<- dir1 (expand-path dir0))
                          (setCurrentDirectory dir1)))
              (return '(:begin))))
        (= warn-unloading
          (++ "Warning: "
              "changing directory causes all loaded modules to be unloaded\n"
              "because the search path has changed.")))
    (case forms
      [] (>>= (expand-path "~") work)
      [arg1] (| ((<- (Just path) (code-to-mb-string arg1))
                 (work path)))
      _ (invalid-form "cd" forms))))

(defn (:: expand-cmd ReplAction)
  "Expand given form for one layer."
  (expand-with "expand" expand1))

(defn (:: expand-full-cmd ReplAction)
  "Fully expand given form."
  (expand-with "expand!" expand))

(defn (:: info-cmd ReplAction)
  [forms]
  (case (map unCode forms)
    [(@ form (Atom (ASymbol _)))] (info-name (toCode form))
    [(Atom AUnit)] (info-name (qSymbol "()"))
    [(HsList [])] (info-name (qSymbol "[]"))
    _ (invalid-form "info" forms)))

(defn (:: in-package-cmd ReplAction)
  [forms]
  ;; Entirely reset the hsc_env, then update dflags with thisInstalledUnitId,
  ;; and then set up the context modules. The update happens only when the given
  ;; package name exist. Using the exact `InstalledUnitId' of the already
  ;; compiled package to specified the unit id.
  (let ((= mb-installed-uid dflags name
          (if (== name (fsLit "main"))
              (return (toInstalledUnitId mainUnitId))
              (do (<- cid (lookupPackageName dflags (PackageName name)))
                  ($ return componentIdToInstalledUnitId cid))))
        (= set-this-installed-uid dflags uid
          (do (<- new-env-0 (liftIO (newHscEnv dflags)))
              (let ((= dflags1 (dflags {thisInstalledUnitId uid}))
                    (= ic1 ((hsc-IC new-env-0) {ic-dflags dflags1}))
                    (= new-env-1
                      (new-env-0 {hsc-dflags dflags1
                                  hsc-IC ic1}))))
              (modifySession (const new-env-1))
              (<- mods (fmap envContextModules getFnkEnv))
              (setContext (map mk-ii-str mods))
              (<- _ (setSessionDynFlags dflags1))
              (<- dflags2 getDynFlags)
              (modifyFnkEnv (\ e (e {envDefaultDynFlags (Just dflags2)})))))
        (= msg dflags name
          (maybe (++ "; package `" (unpackFS name) "' not found")
                 (\ iuid
                   (++ "; current package set to `"
                       (unpackFS (installedUnitIdFS iuid)) "'"))
                 (mb-installed-uid dflags name)))
        (= work name
          (do (<- dflags getDynFlags)
              (mapM_ (set-this-installed-uid dflags)
                     (mb-installed-uid dflags name))
              (pure `(putStrLn ,(msg dflags name))))))
    (case forms
      [form] (| ((<- (Just pkg) (code-to-mb-fs form))
                 (work pkg)))
      _ (invalid-form "in-package" forms))))

;; From `GHCi.UI.kindOfType'
(defn (:: kind-cmd ReplAction)
  [forms]
  (case forms
    [form] (do (<- ty0 (buildHsSyn parseType forms))
               (<- (, _ kind) (evalTypeKind ty0))
               (let ((= sdoc
                       (hsep [(text (show form))
                              dcolon
                              (pprTypeForUser kind)]))))
               (<- str (show-sdoc-for-user-m sdoc))
               (return `(System.IO.putStrLn ,str)))
    _      (invalid-form "kind" forms)))

(defn (:: load-cmd ReplAction)
  "Load a module source code file. Handles absolute paths and relative
paths from import directories."
  [forms]
  (let ((= clear-all
          ;; Cleare various states: finder cache, targets, interactive
          ;; context ... etc.
          (do (<- graph0 getModuleGraph)
              (<- _ abandonAll)
              clear-all-targets
              (<- hsc-env getSession)
              (let ((= graph1 (graph-to-summaries graph0))
                    (= uncache (. (uncacheModule hsc-env) ms_mod_name))))
              (liftIO (do (mapM_ uncache graph1)
                          (flushFinderCaches hsc-env)))
              (setSession (discard-ic hsc-env))))
        (= make-target path
          (do (<- hsc-target (fmap hscTarget getDynFlags))
              (let ((= allow-obj (not (== hsc-target HscInterpreted)))
                    (= tfile (TargetFile path Nothing))))
              (return (Target tfile allow-obj Nothing)))))

    (case forms
      [form] (maybe
              (finkelSrcError form (++ "load: not a FilePath: "
                                       (show form)))
              (\ path
                ;; Clear current state first. Then find the source file
                ;; path and compile, load, and link.
                (do clear-all
                    (env-context-on-exception
                     (do (<- target (make-target path))
                         (<- _ (setTargets [target]))
                         (<- _ (compile-and-import path))
                         (liftIO (putStrLn (++ "; loaded " path)))))
                    (return '(:begin))))
              (code-to-mb-string form))
      _ (invalid-form "load" forms))))

(defn (:: pwd-cmd ReplAction)
  "Function to show current directory."
  [_forms]
  (do (<- dir (liftIO getCurrentDirectory))
      (return `,dir)))

(defn (:: reload-cmd ReplAction)
  "Function to reload previously loaded module."
  [_forms]
  (case-do getTargets
    (: (Target (TargetFile path _) _ _) _)
    ;; Unloading before compilation, to re-link the compiled
    ;; modules.
    (do (<- ctx0 getContext)
        (<- hsc-env getSession)
        (liftIO (unload hsc-env []))
        (<- _ (compile-module path))
        (<- ctx1 (adjust-current-target path ctx0))
        (setContext ctx1)
        (let ((= msg (++ "; reloaded " path))))
        (return `(System.IO.putStrLn ,msg)))
    _ (return '(System.IO.putStrLn "; reload: invalid target"))))

(defn (:: set-cmd ReplAction)
  "Set command line flags, see `GHCi.UI.newDynFlags'."
  [forms]
  (case forms
    (: _ _)
    ;; Always using `setSessionDynFlags' for `set' REPL command to support
    ;; `-package' flag.
    (do (<- dflags0 getSessionDynFlags)
        (let ((= flags (foldr (\ form acc
                                (case (mb-symbol-name form)
                                  (Just name) (: (noLoc name) acc)
                                  _ acc))
                              [] forms))))
        (<- (, dflags1 leftovers warns)
          (parseDynamicFlagsCmdLine dflags0 flags))
        (liftIO
         (do (handleFlagWarnings dflags1 warns)
             (unless (null leftovers)
               (putStrLn
                (++ "Some flags have not been recognized: "
                    (intercalate ", " (map unLoc leftovers)))))))
        (<- _ (setSessionDynFlags dflags1))
        (<- dflags2 getDynFlags)
        (modifySession
         (\ h (let ((= ic0 (hsc-IC h))
                    (= ic1 (ic0 {ic-dflags dflags2})))
                (h {hsc-IC ic1}))))
        ;; Updating the default `DynFlags' used to import modules during macro
        ;; expansion.
        (modifyFnkEnv (\ e (e {envDefaultDynFlags (Just dflags2)})))
        (return '(:begin)))
    _ (finkelSrcError nil "set: empty form")))

(defn (:: show-cmd ReplAction)
  [forms]
  (where go
    (defn go
      (case forms
        [form] (| ((<- (Just name) (mb-symbol-name form))
                   (<- (Just act) (lookup name things))
                   act))
        _ (finkelSrcError nil (++ "show: expecting one of:\n"
                              (intercalate ", " (map fst things))))))
    (defn things
      [(, "bindings" show-bindings)
       (, "context" show-context)
       (, "dflags" show-dflags)
       (, "hpt" show-hpt)
       (, "language" (show-language False))
       (, "linker" show-linker)
       (, "macros" show-macros)
       (, "modules" show-modules)
       (, "options" (show-options False))
       (, "options!" (show-options True))
       (, "packages" show-packages)
       (, "paths" show-paths)
       (, "targets" show-targets)])))

;; From `GHCi.UI.typeOfExpr'.
(defn (:: type-cmd ReplAction)
  [forms]
  (case forms
    [form] (do (<- expanded (expand form))
               (<- expr (buildHsSyn parseExpr [expanded]))
               (<- ty (evalExprType expr))
               (let ((= sdoc
                       (sep [(text (show form))
                             (nest 2 (<+> dcolon
                                          (pprTypeForUser ty)))]))))
               (<- str (show-sdoc-for-user-m sdoc))
               (return `(System.IO.putStrLn ,str)))
    _ (invalid-form "type" forms)))

(defn (:: verbose-cmd ReplAction)
  "Modify verbosity settings in REPL."
  [forms]
  (case forms
    [] (do (<- lvl (fmap envVerbosity getFnkEnv))
           (return
            `(System.IO.putStrLn ,(++ "Verbosity level is " (show lvl)))))
    [form] (| ((<- (Just n) (readMaybe (show form)))
               (do (modifyFnkEnv (setFnkVerbosity n))
                   (let ((= msg (++ "Verbosity level set to " (show n)))))
                   (return `(System.IO.putStrLn ,msg)))))
    _ (invalid-form "verbose" forms)))


;;; REPL command macro

(defn (:: commands [ReplCmd])
  (let ((= c ReplCmd))
    [(c "!" ["CMD" "ARGS" "..."] system-cmd
        "run system CMD with ARGS")
     (c "?" [] help-cmd
        "show this help")
     (c "browse" ["MODULE"] browse-cmd
        "browse contents of MODULE")
     (c "cd" ["DIR"] cd-cmd
        "change working directory to DIR")
     (c "expand" ["FORM"] expand-cmd
        "show expanded result of FORM")
     (c "expand!" ["FORM"] expand-full-cmd
        "show fully expanded result of FORM")
     (c "info" ["NAME"] info-cmd
        "show info of NAME")
     (c "in-package" ["PKG"] in-package-cmd
        "change current package to PKG")
     (c "kind" ["TYPE"] kind-cmd
        "show kind of TYPE")
     (c "load" ["FILE"] load-cmd
        "compile and load FILE")
     (c "pwd" [] pwd-cmd
        "show working directory")
     (c "reload" [] reload-cmd
        "reload previous module")
     (c "set" ["FLAGS" "..."] set-cmd
        "parse and set FLAGS")
     (c "show" ["ARG"] show-cmd
        "show information of ARG")
     (c "type" ["EXPR"] type-cmd
        "show type of EXPR")
     (c "verbose" ["INT"] verbose-cmd
        "set finkel verbosity to INT")]))

(defmacroM repl-macro form
  (case (unCode form)
    (List (: name args)) (case (do (<- name' (code-to-mb-string name))
                                   (find (. (isPrefixOf name') rc-name)
                                         commands))
                           (Just rc) (rc-action rc args)
                           _ (help-cmd []))
    _ (finkelSrcError form (++ "invalid args: " (show form)))))
