;;; Tests for REPL.

%p(language OverloadedStrings)

(:require Finkel.Core)

(defmodule ReplTest
  (export replTests listenTests)
  (import-when [compile]
    ;; finkel-core
    (Finkel.Prelude))
  (import
   ;; base
   (Control.Concurrent
    (forkIO newEmptyMVar killThread putMVar takeMVar threadDelay yield))
   (Control.Exception
    ((IOException ..) bracket catch evaluate finally throwIO))
   (Control.Monad (forever replicateM_ void when))
   (Control.Monad.IO.Class ((MonadIO ..)))
   (Data.List (intercalate isSubsequenceOf))
   (Data.String ((IsString ..)))
   (GHC.Conc ((ThreadStatus ..) threadStatus))

   ;; filepath
   (System.FilePath (</>))

   ;; ghc
   (StringBuffer (StringBuffer stringToStringBuffer))

   ;; haskeline
   (System.Console.Haskeline (defaultSettings runInputT))

   ;; hspec
   (Test.Hspec)

   ;; network
   (Network.Socket
    ((AddrInfo ..) (SocketType ..)
     close connect defaultHints getAddrInfo socket))
   (Network.Socket.ByteString (sendAll recv))

   ;; finkel-kernel
   (Language.Finkel)
   (Language.Finkel.Fnk (runFnk))

   ;; Internal
   (Finkel.Tool.Repl)
   (Finkel.Tool.Repl.Eval)
   (Finkel.Tool.Repl.Loop)
   (Finkel.Tool.Repl.IO)
   (Finkel.Tool.Repl.Types)
   (TestAux)))

;;; Extra imports
(with-ghc-version-cond v
  ((<= 804 v)
   (:begin))
  (otherwise
   (import Data.Monoid (<>))))

;;; Exported test

(defn (:: replTests (-> EvalTestFns Spec))
  [etf]
  (do (describe "ReplState" replStateTests)
      (describe "Read" readTests)
      (describe "ReadPrint"
        (with-os-cond os
          ((== os "mingw32")
           (it "should skip under Windows"
             (pendingWith "Windows not supported yet")))
          (otherwise readPrintTests)))
      (describe "Eval"
        (with-os-cond os
          ((== os "mingw32")
           (it "should skip under Windows"
             (pendingWith "Windows not supported yet")))
          (otherwise (evalTests etf))))))

(defn (:: listenTests (-> EvalTestFns Spec))
  [etf]
  (describe "Listen"
    (with-os-cond os
      ((== os "mingw32")
       (it "should be skipped under Windows"
         (pendingWith "Windows not supported yet")))
      (otherwise (listenTests1 etf)))))

;;; Orphan

(instance (IsString StringBuffer)
  (= fromString stringToStringBuffer))

;;; Internal

(defn (:: replStateTests Spec)
  (do (let ((= d describe)
            (= rs1 (ReplState {pending-input (Just "(foo")}))
            (= rs2 (ReplState {pending-input (Just " bar)")}))))
      (d "Show instance"
         (it "should show pending inputs"
           (shouldBe
            (show rs1)
            "ReplState {pending_input = Just <stringbuffer(4,0)>}")))
      (d "Eq instance"
         (do (it "should equal to itself" (shouldBe rs1 rs1))
             (it "should not equal with different pending input"
               (shouldNotBe rs1 rs2))))
      (d "Monoid laws for ReplState"
         (do (it "should have an identity element"
               (shouldBe (<> mempty rs1) rs1))
             (it "should satisfy associativity law"
               (shouldBe (<> (<> rs1 mempty) rs2)
                         (<> rs1 (<> mempty rs2))))))
      (d "get and put ReplState for InputT"
         (do (let ((= act
                     (run-repl (runInputT defaultSettings work)
                               mempty))
                   (= work
                     (do (putReplState mempty)
                         getReplState))))
             (it "should return the given ReplState"
               (shouldReturn act mempty))))
      (let ((= run-repl' (flip run-repl mempty))
            (= repl1 (pure True))))
      (d "Functor instance of Repl"
         (do (it "should satisfy identity law"
               (shouldReturn (run-repl' (fmap id repl1)) True))
             (it "should satisfy composition law"
               (shouldReturn
                (run-repl' (fmap show (fmap not repl1)))
                (show (not True))))
             (it "should return second arg with <$"
               (shouldReturn
                (run-repl' (<$ True (pure False)))
                True))))
      (d "Applicative instance of Repl"
         (it "should satisfy applicative law"
           (shouldReturn
            (run-repl' (<*> (pure not) repl1))
            False)))))

(defn (:: readTests Spec)
  (do (let ((= d describe)))
      (d "reading single line form"
         (it "returns '(foo bar buzz)"
           (do (<- form (run-repl (read-form "(foo bar buzz)")
                                  initial-repl-state))
               (shouldBe form (Just '(foo bar buzz))))))
      (d "reading multi line form"
         (it "returns '(a b c)"
           (do (<- form (run-repl (do (<- _ (read-form "(a "))
                                      (<- _ (read-form "b "))
                                      (read-form "c)"))
                                  initial-repl-state))
               (shouldBe form (Just '(a b c))))))))

(defn (:: readPrintTests Spec)
  (describe "read and print loop"
    (do (rptest "multi line form" ["(print" "(+" "10" "32" "))"])
        (rptest "quitting with \"(quit)\"" ["(quit)"])
        (rptest "\",t\" command" [",t False"])
        (rptest "\",!\" command" [",! echo foo bar"])
        (rptest "\",q\" command" [",q"]))))

(defn (:: rptest (-> String [String] Spec))
  [label inputs]
  (let ((= run
          (do (<- in-mv newEmptyMVar)
              (<- tid (forkIO (forever
                               (do (<- (Input _ _ out-mv) (takeMVar in-mv))
                                   (putMVar out-mv (Right ""))))))
              (return (, in-mv tid)))))
    (describe label
      (it "should have no pending inputs"
        (do (<- (, in-mv tid) run)
            (<- (, _ tst) (runTestIO (read-print-loop in-mv tid) inputs))
            (finally
             (shouldSatisfy (pending-input (tst-replstate tst)) null)
             (killThread tid)))))))

(defn (:: evalTests (-> EvalTestFns Spec))
  [(EvalTestFns {etf-ok ok etf-ng ng etf-satisfy satisfy})]
  (do
    ;; Statements and declarations
    (ok '(+ 10 32) "42")
    (ok '(defn (:: f1 (-> Int Int))
          [n]
          (+ n 1))
        "; f1 :: Int -> Int")
    (ok '(f1 41) "42")
    (ok '(:begin
          (:: (x y) Int)
          (= x 1)
          (= y 2))
        "; x :: Int\n; y :: Int")
    (ok '(<- z (return True))
        "; z :: Bool")
    (ok '(defn (:: f2 (-> (Maybe Int) Int))
          [(Just n)] (* n 2)
          [Nothing] 0)
        "; f2 :: Maybe Int -> Int")
    (ok '(f2 (Just 21)) "42")
    (ok '(data Foo (Foo Int))
        (concat ["; $tcFoo :: TyCon\n"
                 "; $tc'Foo :: TyCon\n"
                 "; Type constructor ‘Foo’"]))

    ;; Import
    (ok '(import Control.Monad)
        "; import Control.Monad")
    (ok '(import qualified Data.Functor as DF)
        "; import qualified Data.Functor as DF")
    (ok '(import Control.Monad (liftM ap))
        "; import Control.Monad ( liftM, ap )")

    ;; Eval wrapper
    (ok 'System.Environment.getArgs "[]")

    ;; Expansion quoted codes in REPL
    (ok '(macroexpand ''foo)
        "(Language.Finkel.qSymbol \"foo\")")
    (ok '(macroexpand '`(a ,@(b) c))
        (concat
         ["(Language.Finkel.qList (Data.Foldable.concat ["
          "[(Language.Finkel.qSymbol \"a\")] "
          "(Language.Finkel.unquoteSplice ((b))) "
          "[(Language.Finkel.qSymbol \"c\")]"
          "]))"]))

    ;; Exported macros
    (satisfy '(exported-macros Finkel.Core)
             (\ result
               (case result
                 (Right str) (isSubsequenceOf "defmacro" str)
                 _ False)))

    ;; Errors
    (ng 'buzz
        (concat ["<interactive>:1:1: error: "
                 "Variable not in scope: buzz"]))
    (ng '(= f a (+ a 1) (+ a 2))
        (concat
         ["<quoted code>: error:\n"
          "    syntax error on input `(= f a (+ a 1) (+ a 2))'"]))
    (ng '(head [])
        "*** Exception: Prelude.head: empty list")))

(defn (:: listenTests1 (-> EvalTestFns Spec))
  [(EvalTestFns {etf-tid etid})]
  (let ((= with-repl-connection
          (bracket acquire release))
        (= short-pause (threadDelay 50000))
        (= wait-until-killed tid
          (do (<- st (threadStatus tid))
              (putStrLn (++ "listenTests1: " (show st)))
              (when (notElem st [ThreadFinished ThreadDied])
                (do short-pause
                    (wait-until-killed tid)))))
        (= acquire
          (do (wait-until-killed etid)
              (<- tid (forkIO
                       ;; Passing a file to work for, so that the REPL thread
                       ;; will not terminate before the testing client connect.
                       (replMain [(++ "--listen=" port)
                                  (++ "--file=" input-file)])))
              ;; Pause for a bit after forking the server action.
              (replicateM_ 5 short-pause)
              (<- addr (resolve "127.0.0.1" port))
              (<- conn (socket (addrFamily addr)
                               (addrSocketType addr)
                               (addrProtocol addr)))
              (with-retry 20
                (connect conn (addrAddress addr)))
              (return (, conn tid))))
        (= with-retry n act
          (catch act
            (\ e
              (if (< 0 n)
                  (do yield
                      short-pause
                      (with-retry (- n 1) act))
                  (throwIO (:: e IOException))))))
        (= release (, conn tid)
          (do (sendAll conn ",quit")
              (<- _msg (recv conn 1024))
              (close conn)
              (killThread tid)))
        (= port "50322")
        (= input-file (</> "test" "data" "sleep-for-while.fnk"))
        (= resolve host port
          (let ((= hints (defaultHints {addrSocketType Stream})))
            (case-do (getAddrInfo (Just hints) (Just host) (Just port))
              (: addr _) (return addr)
              _ (error "REPL client: address error"))))
        (= work (, conn _)
          (do (<- _msg1 (recv conn 1024))
              (sendAll conn "(* 7 (+ 4 2))")
              (recv conn 1024)))
        (= listener-test
          (describe "listener"
            (it "evaluates a form sent from connected client"
              (\ args (shouldReturn (work args) "42"))))))
    (before acquire (after release listener-test))))
