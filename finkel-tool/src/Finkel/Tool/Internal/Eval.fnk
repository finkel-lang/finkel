;;; Eval loop in REPL.

(:require Finkel.Core)

(defmodule Finkel.Tool.Internal.Eval
  (export eval-loop eval-once)
  (require
   ;; finkel-core
   (Finkel.Core.Ghc))
  (import-when [:compile]
   ;; finkel-core
   (Finkel.Prelude))
  (import
   ;; base
   (Control.Concurrent.MVar [MVar putMVar takeMVar])
   (Control.Exception
    [(AsyncException ..) (Exception ..) fromException throwIO])
   (Control.Monad (unless))
   (Control.Monad.IO.Class [(MonadIO ..)])
   (Data.List [intercalate])
   (System.IO [Handle])
   (qualified System.Exit)

   ;; exceptions
   (Control.Monad.Catch [handle])

   ;; ghc-boot
   (GHC.LanguageExtensions [(Extension ..)])

   ;; ghci
   (GHCi.Message [(EvalExpr ..) (EvalResult ..) (EvalStatus_ ..)
                  (SerializableException ..)])
   (GHCi.RemoteTypes (ForeignHValue))

   ;; finkel-kernel
   (Language.Finkel)
   (Language.Finkel.Builder [HDecl HIE HImportDecl HStmt
                             syntaxErrCode syntaxErrMsg evalBuilder])
   (Language.Finkel.Eval [evalDecls])
   (Language.Finkel.Exception [finkelExceptionLoc])
   (Language.Finkel.Make [initSessionForMake isFnkFile isHsFile])
   (Language.Finkel.Fnk
    [(FnkEnv ..) failFnk modifyFnkEnv prepareInterpreter setDynFlags
     withTmpDynFlags])
   (Language.Finkel.Syntax [parseExpr parseImports parseStmt parseTopDecls])

   ;; internal
   (Finkel.Tool.Internal.IO)
   (Finkel.Tool.Internal.Macro)
   (Finkel.Tool.Internal.Types)))

(imports-from-ghc
 (GHC
  ((Target ..) (TargetId ..) getPrintUnqual parseDynamicFlags setTargets))
 (GHC.Types.Basic ((SuccessFlag ..)))
 (GHC.Data.Bag (unitBag))
 (GHC.Driver.Session
  ((DynFlags ..) (GeneralFlag ..) (HasDynFlags ..) (HscTarget ..) (Option ..)
   gopt-set xopt-unset))
 (GHC.Utils.Error (mkErrMsg pprErrMsgBagWithLoc))
 (GHC.Runtime.Interpreter (evalStmt))
 (GHC.Driver.Main (hscParsedStmt))
 (GHC.Driver.Monad
  ((GhcMonad ..) getSessionDynFlags modifySession withTempSession))
 (GHC.Driver.Types
  ((HscEnv ..) (InteractiveContext ..) (InteractiveImport ..)
   FixityEnv SourceError extendInteractiveContextWithIds
   handleFlagWarnings setInteractivePrintName srcErrorMessages))
 (GHC.Runtime.Eval
  (compileParsedExprRemote getContext parseName setContext))
 (GHC.Runtime.Linker (extendLinkEnv))
 (GHC.Unit.Module (mkModuleName))
 (GHC.Types.Name ((Name) getName nameOccName occNameString))
 (GHC.Data.OrdList (toOL))
 (GHC.Utils.Outputable
  (SDoc PrintUnqualified ppr mkErrStyle renderWithStyle setStyleColoured
        showPpr showSDoc text vcat))
 (GHC.Parser.PostProcess (cvTopDecls))
 (GHC.Types.SrcLoc (mkGeneralLocated unLoc))
 (GHC.Core.TyCo.Rep ((TyThing ..)))
 (GHC.Utils.Misc (looksLikeModuleName))
 (GHC.Types.Var (Id Var varType)))


;;; Extra imports

(cond-expand
  [(<= 900 :ghc)
   (import GHC.Utils.Outputable (initSDocContext))]
  [otherwise
   (:begin)])

(cond-expand
  [(<= 810 :ghc)
   ;; ghc
   (import GHC.Hs.ImpExp ((ImportDecl ..) (ImportDeclQualifiedStyle)
                          isImportDeclQualified))]
  [otherwise
   ;; ghc
   (import HsImpExp ((ImportDecl ..)))])

;;; Version compatibility function

(cond-expand
  [(<= 810 :ghc)
   (:begin
     (defn (:: extend-link-env (-> HscEnv [(, Name ForeignHValue)] (Fnk ())))
       [hsc-env names-vals]
       (liftIO (extendLinkEnv (hsc-dynLinker hsc-env) names-vals)))
     (defn (:: is-import-decl-qualified (-> ImportDeclQualifiedStyle Bool))
       isImportDeclQualified))]
  [otherwise
   (:begin
     (defn (:: extend-link-env (-> a [(, Name ForeignHValue)] (Fnk ())))
       [_ names-vals]
       (liftIO (extendLinkEnv names-vals)))
     (defn (:: is-import-decl-qualified (-> Bool Bool))
       id))])

(defn (:: optional-dynflags [GeneralFlag])
  "Optional 'GeneralFlag' set for REPL."
  (cond-expand
    [(<= 804 :ghc)
     [Opt_ImplicitImportQualified
      Opt_IgnoreOptimChanges
      Opt_IgnoreHpcChanges]]
    [otherwise
     [Opt_ImplicitImportQualified]]))


;;; Eval loop

(defn (:: init-eval-loop (-> [String] [String] (Fnk ForeignHValue)))
  "Initialization works for evaluation loop."
  [eval-wrapper-opts ghc-opts]
  (do prepareInterpreter
      (<- hsc-env0 getSession)

      ;; Parse the ghc options from argument, assuming that the arguments are
      ;; passed from the command line.
      (let ((= on-the-commandline (mkGeneralLocated "on the commmandline"))
            (= lghc-opts (map on-the-commandline ghc-opts))))
      (<- (, dflags0 fileish warns)
        (parseDynamicFlags (hsc-dflags hsc-env0) lghc-opts))
      (liftIO (handleFlagWarnings dflags0 warns))

      ;; As done in the Main.hs in "ghc-bin" package, updating the `ldInputs'
      ;; field o the `DynFlags' with `FileOption', to support linking object
      ;; files.
      (let ((= dflags1 (foldl gopt-set dflags0 optional-dynflags))
            (= (, srcs objs) (partition-args fileish))
            (= dflags2
              (dflags1 {ldInputs (++ (map (. (FileOption "") unLoc) objs)
                                     (ldInputs dflags1))}))))

      ;; Initializing plugins with dflags from updated session.
      (setDynFlags dflags2)

      initSessionForMake

      (<- dflags3 getDynFlags)

      ;; Setting the default `DynFlags' for macro expansion.
      (modifyFnkEnv (\ e (e {envDefaultDynFlags (Just dflags3)})))

      ;; Load modules specified from command line, when given.
      (unless (null srcs)
        (handle
         (\ e
           (cond
             [(<- (Just se) (fromException e))
              (>>= (make-src-err-message se) (. liftIO putErrLn))]
             [(<- (Just fe) (fromException e))
              (>>= (make-finkel-exception-message fe) (. liftIO putErrLn))]
             [otherwise
              (liftIO (printErr e))]))
         (case-do (do (setTargets (map guessFnkTarget srcs))
                      (compile-and-import srcs))
           Failed (liftIO
                   (putErrLn (++ "failed loading: "
                                 (intercalate ", " (map unLoc fileish)))))
           Succeeded (return ()))))

      ;; XXX: Currently the printer function and the arguments returned from
      ;; "System.Environment.getArgs" are defined here and cannot be changed.
      (set-print-name "System.IO.print")

      ;; Pass the argument to evaluation wrapper, to set the value of `argv'
      ;; returned from `System.Environment.getArgs'.
      (make-eval-wrapper eval-wrapper-opts)))

(defn (:: eval-loop (-> [String] Handle (MVar Input) (Fnk ())))
  "Loop to evaluate expressions."
  (eval-loop-or-once False []))

(defn (:: eval-once (-> [String] [String] Handle (MVar Input) (Fnk ())))
  "Evalute the form once and return."
  (eval-loop-or-once True))

(defn (:: eval-loop-or-once
        (-> Bool [String] [String] Handle (MVar Input) (Fnk ())))
  "Evaluate expressions, and loop or return."
  [once-only wrapper-args ghc-opts hdl in-mvar]
  (let ((= withAsyncHandler wrapper
          (handle
           (\ e
             (case (fromException e)
               (Just UserInterrupt) (loop wrapper)
               (Just ThreadKilled)  (return ())
               _ (liftIO (throwIO e))))))
        (:: throw-async-io (-> AsyncException (Fnk a)))
        (= throw-async-io (. liftIO throwIO))
        (= withErrorHandler m
          (handle
           (\ e
             (cond
               [(<- (Just se) (fromException e))
                (fmap Left (make-src-err-message se))]
               [(<- (Just ae) (fromException e))
                (throw-async-io ae)]
               [(<- (Just fe) (fromException e))
                (fmap Left (make-finkel-exception-message fe))]
               [otherwise
                ($ pure Left show e)]))
           m))
        (= eval-one wrapper
          (do (<- (Input itype form out-mv) (liftIO (takeMVar in-mvar)))
              (<- ret (withErrorHandler
                       (do (<- expanded (expands [form]))
                           (<- dflags getDynFlags)
                           (eval-form hdl dflags wrapper itype expanded))))
              (liftIO (putMVar out-mv ret))))
        (= loop wrapper
          (withAsyncHandler wrapper
                            (>> (eval-one wrapper)
                                (loop wrapper)))))
    (>>= (init-eval-loop wrapper-args ghc-opts)
         (if once-only eval-one loop))))

(defn (:: set-print-name (-> String (Fnk ())))
  "Set the name of function used for printing values in interactive
context."
  [name]
  (case-do (parseName name)
    (: f _) (modifySession
             (\ he (he {hsc-IC (setInteractivePrintName (hsc-IC he) f)})))
    _ (failFnk "set-print-name: parse error")))

(defn (:: eval-form
        (-> Handle DynFlags ForeignHValue InSource [Code] (Fnk Result)))
  [hdl dflags wrapper itype forms]
  (| ((null forms)
      (return (Right "")))
     ((<- (Right stmt) (evalBuilder dflags True parseStmt forms))
      (eval-statement hdl wrapper itype stmt))
     ((<- (Right decls) (evalBuilder dflags True parseTopDecls forms))
      (eval-decls decls))
     (otherwise
      (case (evalBuilder dflags True parseImports forms)
        (Right idecl) (eval-imports dflags idecl)
        (Left se) (finkelSrcError (syntaxErrCode se) (syntaxErrMsg se))))))

(defn (:: eval-statement
        (-> Handle ForeignHValue InSource HStmt (Fnk Result)))
  [hdl wrapper itype stmt0]
  (do (<- hsc-env getSession)
      (case-do (liftIO (hscParsedStmt hsc-env stmt0))
        (Just (, is h f)) (update-hsc-env hdl wrapper itype hsc-env is h f)
        Nothing (return (Left "eval-statement: no result")))))

(defn (:: eval-imports (-> DynFlags [HImportDecl] (Fnk Result)))
  [dflags imports]
  (do (<- ctx0 getContext)
      (let ((= mkIIDecl (L _ idecl)
              (IIDecl idecl))
            (= imps (map (. (showSDoc dflags) ppr) imports))
            (= mdls (++ "; " (intercalate ", " imps)))
            (= ctx1 (foldr (\ mdl (add-gt-ii (mkIIDecl mdl)))
                           ctx0 imports))))
      (setContext ctx1)
      (return (Right mdls))))

(defn (:: eval-decls (-> [HDecl] (Fnk Result)))
  [decls]
  (do (<- hsc-env getSession)
      (let ((= decls' (cvTopDecls (toOL decls)))
            (= dflags (hsc-dflags hsc-env))
            (= pr tt
              (case tt
                (AnId var) (var-name-and-type dflags (getName var) var)
                _ (++ "; " (showSDoc dflags (ppr tt)))))
            (= show-tything tt acc
              (let ((= nstr (showSDoc dflags (ppr (getName tt)))))
                (if (== "$trModule" nstr)
                    acc
                    (: (pr tt) acc))))
            (= tystr tt
              (intercalate "\n" (foldr show-tything [] tt)))))

      ;; In "ghc/GHCi/UI.hs", the `runStmt' function is wrapping declarations
      ;; with `let' expression and passing to `execStmt'' as a work around for
      ;; supporting top level declaration. However, this approach seems like
      ;; not working well when multiple declarations were entered at once.
      ;;
      ;; In finkel REPL, instead of wrapping with `let', always using
      ;; `HscInterpreted' as target when evaluating declarations to support
      ;; declaring functions and values when REPL were using `-fobject-code'.
      (<- (, tythings ic)
        (withTmpDynFlags (dflags {hscTarget HscInterpreted})
                         (evalDecls decls')))

      (setSession (hsc-env {hsc-IC ic}))
      (return (Right (tystr tythings)))))

(defn (:: update-hsc-env (-> Handle ForeignHValue InSource HscEnv
                             [Id] ForeignHValue FixityEnv (Fnk Result)))
  [hdl wrapper itype hsc-env ids hvals-io fixity-env]
  ;; The `evalStmt' below is from "compiler/ghci/GHCi.hsc", which uses
  ;; `iservCmd' in its implementation.
  (let ((= success fhvals _elapsed ret
          (do (let ((= ic (hsc-IC hsc-env))
                    (= ic2 (extendInteractiveContextWithIds ic ids))
                    (= ic3 (ic2 {ic-fix-env fixity-env}))
                    (= names (map getName ids))
                    (= hsc-env-2 (hsc-env {hsc-IC ic3}))))
              (<- dflags getSessionDynFlags)
              (extend-link-env hsc-env (zip names fhvals))

              ;; InteractiveEval does not export `rttiEnvironment'.
              ;;
              ;; (<- hsc-env-3
              ;;     (liftIO
              ;;      (rttiEnvironment (hscenv {hsc_IC final-ic}))))

              (setSession hsc-env-2)
              (case names
                [name] (| ((== (occNameString (nameOccName name)) "it")
                           (return (Right ret))))
                _ (return
                   (Right (names-and-types dflags names ids))))))
        (= exception serialized
          (case serialized
            (EOtherException e) (return (Left (++ "*** Exception: " e)))
            (EExitCode ecode) (liftIO (System.Exit.exitWith ecode))
            EUserInterrupt (return (Left "Interrupted."))))
        (= incomplete
          (return (Left "update-hsc-env failed.")))
        (= eval-hvals-io
          (evalStmt hsc-env False (EvalApp (EvalThis wrapper)
                                           (EvalThis hvals-io))))
        (= eval-for-prompt
          (do (<- status (liftIO eval-hvals-io))
              (return (, status ""))))
        (= eval-for-connection
          (liftIO (with-io-redirect hdl eval-hvals-io))))
    (do (<- (, status ret)
          ;; Switching behaviour between prompt and network connection. Getting
          ;; printed result as `String' for connection by wrapping the execution
          ;; of compiled result, which is a value of `IO [HValue]' type.
          (case itype
            Prompt eval-for-prompt
            Connection eval-for-connection))
        (case status
          (EvalComplete et (EvalSuccess hvs)) (success hvs et ret)
          (EvalComplete  _ (EvalException e)) (exception e)
          _ incomplete))))


;;; Auxiliary

(defn (:: guessFnkTarget (-> (Located String) Target))
  "Simple function to do similar work done in `GHC.guessTarget', to support
source code file paths with @.fnk@ extension."
  [lsrc]
  (let ((= src (unLoc lsrc))
        (= tid (if (looksLikeModuleName src)
                   (TargetModule (mkModuleName src))
                   (TargetFile src Nothing))))
    (Target tid True Nothing)))

(defn (:: partition-args
        (-> [(Located String)] (, [(Located String)] [(Located String)])))
  "Simplified version of the function with same name defined in @ghc/Main.hs@,
to separate object files from source code files."
  (let ((= f (L l arg) (, srcs objs)
          (if (|| (isFnkFile arg)
                  (isHsFile arg)
                  (looksLikeModuleName arg))
              (, (: (L l arg) srcs) objs)
              (, srcs (: (L l arg) objs)))))
    (foldr f (, [] []))))

(defn (:: render-with-err-style (-> DynFlags PrintUnqualified SDoc String))
  [dflags unqual sdoc]
  (cond-expand
    [(<= 900 :ghc)
     (let ((= style0 (mkErrStyle unqual))
           (= style1 (setStyleColoured True style0)))
       (renderWithStyle (initSDocContext dflags style1) sdoc))]
    [otherwise
     (let ((= style0 (mkErrStyle dflags unqual))
           (= style1 (setStyleColoured True style0)))
       (renderWithStyle dflags sdoc style1))]))

(defn (:: make-src-err-message (-> SourceError (Fnk String)))
  [src-err]
  (do (<- dflags getSessionDynFlags)
      (<- unqual getPrintUnqual)
      (let ((= emsgs (srcErrorMessages src-err))
            (= sdoc (vcat (pprErrMsgBagWithLoc emsgs)))))
      (return (render-with-err-style dflags unqual sdoc))))

(defn (:: make-finkel-exception-message (-> FinkelException (Fnk String)))
  [fe]
  (do (<- dflags getDynFlags)
      (<- unqual getPrintUnqual)
      (let ((= msg (displayException fe))
            (= lmsg l
              (let ((= emsgs (unitBag (mkErrMsg dflags l unqual (text msg))))
                    (= sdoc (vcat (pprErrMsgBagWithLoc emsgs))))
                (render-with-err-style dflags unqual sdoc)))))
      (case (finkelExceptionLoc fe)
        (Just l) ($ return lmsg l)
        _ (return msg))))

(defn (:: make-eval-wrapper (-> [String] (Fnk ForeignHValue)))
  [args]
  (do (let ((= form
              `(\ m (do (<- r (System.Environment.withArgs ,args m))
                        (System.IO.hFlush System.IO.stdout)
                        (System.IO.hFlush System.IO.stderr)
                        (Control.Monad.return r))))
            (= no-rb-hsc hsc-env
              (hsc-env {hsc-dflags (xopt-unset (hsc-dflags hsc-env)
                                               RebindableSyntax)}))))
      (<- dflags getDynFlags)
      (case (evalBuilder dflags True parseExpr [form])
        (Right expr) (withTempSession no-rb-hsc
                                      (compileParsedExprRemote expr))
        (Left err) (finkelSrcError (syntaxErrCode err)
                                   (syntaxErrMsg err)))))

(defn (:: var-name-and-type (-> DynFlags Name Var String))
  [dflags name var]
  (let ((= nstr (occNameString (nameOccName name)))
        (= typ (showPpr dflags (varType var))))
    (if (== nstr "it")
        ""
        (intercalate "\n"
                     (map (++ "; ")
                          (lines (++ nstr (++ " :: " typ))))))))

(defn (:: names-and-types (-> DynFlags [Name] [Var] String))
  [dflags names vars]
  (let ((= tvs (zipWith (var-name-and-type dflags) names vars)))
    (if (all null tvs)
        ""
        (intercalate "\n" tvs))))

(defn (:: add-gt-ii (-> InteractiveImport [InteractiveImport]
                        [InteractiveImport]))
  [mdl acc]
  (if (any (subsume-ii mdl) acc)
      acc
      (: mdl acc)))

(defn (:: subsume-ii (-> InteractiveImport InteractiveImport Bool))
  ;; See `GHCi.UI.iiSubsumes'.
  [(IIModule x) (IIModule y)] (== x y)
  [(IIDecl x) (IIDecl y)] (&& (== (unLoc (ideclName x)) (unLoc (ideclName y)))
                              (== (ideclAs x) (ideclAs y))
                              (|| (not (is-import-decl-qualified
                                        (ideclQualified x)))
                                  (is-import-decl-qualified
                                   (ideclQualified y)))
                              (hiding-subsumes (ideclHiding x)
                                               (ideclHiding y)))

  [_ _] False)

(defn (:: hiding-subsumes (-> (Maybe (, Bool (Located [HIE])))
                              (Maybe (, Bool (Located [HIE])))
                              Bool))
  [_                         (Just (, False (L _ [])))] True
  [(Just (, False (L _ xs))) (Just (, False (L _ ys)))] (all (flip elem xs) ys)
  [a                         b                        ] (== a b))
