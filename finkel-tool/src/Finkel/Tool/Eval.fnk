;;;; Eval sub command

(:require Finkel.Core)

(defmodule Finkel.Tool.Eval
  (export evalMain
          eval-and-exit
          eval-and-exit-with-args)
  (require
   ;; finkel-core
   (Finkel.Core.Ghc))
  (import
   ;; base
   (Control.Concurrent (MVar newEmptyMVar newMVar takeMVar))
   (Control.Monad.IO.Class ((MonadIO ..)))
   (System.Console.GetOpt
    ((ArgDescr ..) (ArgOrder ..) (OptDescr ..) getOpt usageInfo))
   (System.Environment (getProgName))
   (System.Exit (exitFailure))

   ;; finkel-kernel
   (Language.Finkel.Fnk
    ((Fnk) FnkEnv runFnk fromFnkEnvOptions fnkEnvOptionsUsage))
   (Language.Finkel.Form (Code))
   (Language.Finkel.Lexer (evalSP))
   (Language.Finkel.Reader (sexpr))

   ;; Internal
   (Finkel.Tool.CLI)
   (Finkel.Tool.Repl (repl-env))
   (Finkel.Tool.Repl.Eval)
   (Finkel.Tool.Repl.IO)
   (Finkel.Tool.Repl.Types)))

(imports-from-ghc
 (GHC.Data.StringBuffer (stringToStringBuffer)))



;;; Exported

(defn (:: evalMain (=> (CLI m) (-> [String] (m ()))))
  [args]
  (let ((= all-opts (++ eval-opts eval-fnk-env-opts))
        (= (, es gs) (partition-descrs all-opts args))
        (= mk-opt (foldl (flip id) initial-eval-option)))
    (case (getOpt Permute all-opts es)
      (, o _ _) (do-eval (mk-opt o) gs))))


;;; Internal

(data EvalOption
  (EvalOption {eo-help Bool
               eo-fnk-env FnkEnv}))

(defn (:: initial-eval-option EvalOption)
  (EvalOption {eo-help False
               eo-fnk-env repl-env}))

(defn (:: eval-opts [(OptDescr (-> EvalOption EvalOption))])
  [(Option [] ["help"]
           (NoArg (\ o (o {eo-help True})))
           "Show this help and exit")])

(defn (:: eval-fnk-env-opts [(OptDescr (-> EvalOption EvalOption))])
  (fromFnkEnvOptions (\ f o (o {eo-fnk-env (f (eo-fnk-env o))}))))

(defn (:: print-eval-help (=> (CLI m) (m ())))
  (do (<- me (liftIO getProgName))
      (putString
       (unlines
        [(concat ["USAGE: " me " eval [OPTIONS] FORM"])
         ""
         "Evaluate given FORM expression."
         ""
         (usageInfo "OPTIONS:\n" eval-opts)
         (fnkEnvOptionsUsage "DEBUG OPTIONS:\n")
         others-passed-to-ghc]))))

(defn (:: do-eval (=> (CLI m) (-> EvalOption [String] (m ()))))
  [eo args]
  (if (eo-help eo)
      print-eval-help
      (let ((= (, ghc-args mb-str) (separate-args args))
            (= parse (. (evalSP sexpr (Just "<eval>")) stringToStringBuffer)))
        (liftIO
         (case mb-str
           (Just str) (case (parse str)
                        (Right form) (eval-and-exit ghc-args (eo-fnk-env eo) form)
                        (Left err) (>> (putErrLn err) exitFailure))
           Nothing (>> print-eval-help exitFailure))))))

(defn (:: separate-args (-> [String] (, [String] (Maybe String))))
  [args]
  (case args
    [] (, [] Nothing)
    [x] (, [] (Just x))
    (: x xs) (let ((= (, ghc-opts mb-form) (separate-args xs)))
               (, (: x ghc-opts) mb-form))))

(defn (:: eval-and-exit (-> [String] FnkEnv Code (IO ())))
  (eval-and-exit-with-args []))

(defn (:: eval-and-exit-with-args (-> [String] [String] FnkEnv Code (IO ())))
  [wrapper-args ghc-args fnk-env form]
  (runFnk
   (do (let ((= hdl (error "eval-and-exit: uninitialized handle"))))
       (<- (, in-mv out-mv) (make-in-and-out form))
       (eval-once wrapper-args ghc-args hdl in-mv)
       (liftIO (case-do (takeMVar out-mv)
                 (Right msg) (putStr msg)
                 (Left errs) (>> (putErrLn errs) exitFailure))))
   fnk-env))

(defn (:: make-in-and-out (-> Code (Fnk (, (MVar Input) (MVar Result)))))
  [form]
  (liftIO
   (do (<- out-mv newEmptyMVar)
       (<- in-mv (newMVar (Input Prompt form out-mv)))
       (return (, in-mv out-mv)))))
