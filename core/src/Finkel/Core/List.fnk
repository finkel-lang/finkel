;;; Fundamental functions for list

%p(LANGUAGE FlexibleInstances
            TypeSynonymInstances)

(:doc "List related functions.

This module is compiled before defining core macros, since some of the
functions defined in this modules are used in macro defined in
\"Finkel.Core\" module.")

(module Finkel.Core.List
  (:dh1 "Predicates")
  is-atom is-pair is-list is-hslist
  is-symbol is-string is-char is-integer is-fractional is-unit

  (:dh1 "Atom constructors")
  make-symbol

  (:dh1 "Atom extractors")
  mb-symbol-name mb-symbol-name-fs

  (:dh1 "Converting")
  curve rev unsnoc

  (:dh1 "Code constructors")
  cons list (Listable ..) append

  (:dh1 "CXrs")
  (:dh2 "Basic cXrs")
  car cdr

  (:dh2 "Composed cXrs")
  (:doc$ cxr)

  caar cadr
  caaar caadr cadar caddr
  caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr

  cdar cddr
  cdaar cdadr cddar cdddr
  cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr

  (:dh1 "Higher order functions")
  reduce reduce1 mapcar keep

  (:dh1 "Exception")
  (FinkelListException ..))

;;; Compile time imports

(:eval-when-compile
  ;; base
  (import Prelude)
  (import Control.Exception (throw))
  (import Data.List (intersperse))

  ;; finkel-kernel
  (import Language.Finkel)
  (import Language.Finkel.Fnk ((FinkelException ..))))

;;; Imports

;; base
(import Control.Exception ((Exception ..) throw))

;; ghc
(import FastString (FastString unpackFS))
(import SrcLoc (SrcSpan getLoc))

;; finkel-kernel
(import Language.Finkel)
(import Language.Finkel.Form (mkLocatedForm toListL))


;;; Exception

(data FinkelListException
  (NonListValue String))

(instance (Show FinkelListException)
  (= show e
    (case e
      (NonListValue str) str)))

(instance (Exception FinkelListException))

(:: error-non-list (-> String Code a))
(= error-non-list fname what
  (throw (NonListValue
          (concat ["Finkel.Core.List." fname
                   ": non-list value `" (show what) "'"]))))


;;; Predicates

(:doc "True when the argument is an 'Atom' or 'nil'.

==== __Examples__

>>> (is-atom \'foo)
True
>>> (is-atom nil)
True
>>> (is-atom '(a b c))
False
>>> (is-atom '[a b c])
False
")
(:: is-atom (-> Code Bool))
(= is-atom (LForm (L _ form))
  (case form
    (Atom _)  True
    (List []) True
    _         False))

(:doc "True when the argument is a non-nil 'List'.")
(:: is-pair (-> Code Bool))
(= is-pair (LForm (L _ form))
  (case form
    (List []) False
    (List _)  True
    _         False))

(:with-macro ((= defpred
                (Macro (\ form
                         (case (unCode form)
                           (List [_ doc name pat])
                           (return `(:begin
                                      (:doc ,doc)
                                      (:: ,name (-> Code Bool))
                                      (= ,name (LForm (L _ form))
                                        (case form
                                          ,pat True
                                          _    False))))
                           _ (finkelSrcError form "defpred"))))))
  (defpred "True when the argument is a 'List'."
      is-list (List _))
  (defpred "True when the argument is a 'HsList'."
      is-hslist (HsList _))
  (defpred "True when the argument is an 'ASymbol'."
      is-symbol (Atom (ASymbol _)))
  (defpred "True when the argument is an 'AString'."
      is-string (Atom (AString _ _)))
  (defpred "True when the argument is an 'AChar'."
      is-char (Atom (AChar _ _)))
  (defpred "True when the argument is an 'AInteger'."
      is-integer (Atom (AInteger _)))
  (defpred "True when the argument is an 'AFractional'."
      is-fractional (Atom (AFractional _)))
  (defpred "True when the argument is an 'AUnit'."
      is-unit (Atom AUnit)))


;;; CONS

(:doc "Extend the second argument with the first argument by appending
to the tip.

Consing to 'HsList' will result in 'List', and consing to non-list value
will create a new 'List' instead of a /dotted-pair/.

==== __Examples__

>>> (cons 'a '(b c))
(a b c)
>>> (cons 'a '[b c])
(a b c)
>>> (cons '(a b) '(c d))
((a b) c d)
>>> (cons '[a b] '[c d])
([a b] c d)
>>> (cons 'a 'b)
(a b)
")
(:: cons (=> (ToCode a) (ToCode b) (-> a b Code)))
(= cons a b
  (let ((= (@ hd (LForm (L l0 _))) (toCode a))
        (= (@ whole (LForm (L _ xs))) (toCode b)))
    (LForm (L l0 (case xs
                   (List xs')   (List (: hd xs'))
                   (HsList xs') (List (: hd xs'))
                   _            (List [hd whole]))))))
%p(INLINABLE cons)

(:doc "Append two lists.")
(:: append (-> Code Code Code))
(= append xs ys
  (| ((not (|| (is-list xs) (is-hslist xs)))
      (error-non-list "append" xs))
     ((not (|| (is-list ys) (is-hslist ys)))
      (error-non-list "append" ys))
     (otherwise
      (let ((:: go (-> Code Code Code))
            (= go as bs
              (if (null as)
                  bs
                  (cons (car as) (go (cdr as) ys)))))
        (go xs ys)))))
%p(INLINABLE append)

(:doc "Make `ASymbol' from given `String'.")
(:: make-symbol (-> String Code))
(= make-symbol qSymbol)
%p(INLINABLE make-symbol)

(:doc "Extract string from given symbol.

Get `Just' `String' when the argument code was an `ASymbol', otherwise
`Nothing'.")
(:: mb-symbol-name (-> Code (Maybe String)))
(= mb-symbol-name (. (fmap unpackFS) mb-symbol-name-fs))
%p(INLINABLE mb-symbol-name)

(:doc "Extract `FastString' from given symbol.

Like `mb_symbol_name', but returns `FastString'")
(:: mb-symbol-name-fs (-> Code (Maybe FastString)))
(= mb-symbol-name-fs form
  (case form
    (LForm (L _ (Atom (ASymbol name)))) (Just name)
    _ Nothing))
%p(INLINABLE mb-symbol-name-fs)

(:doc "Convert `HsList' to `List'.

The original value is retained if the given argument was not a `HsList' value.")
(:: curve (-> Code Code))
(= curve form
  (if (is-hslist form)
      (toListL form)
      form))
%p(INLINABLE curve)

(:doc "Type class for constructing 'List' with polyvariadic function.")
(class (Listable l)
  (:: list_ (-> [Code] l)))

(instance (Listable Code)
  (= list_ xs
    (case (mkLocatedForm (reverse xs))
      (L l ys) (LForm (L l (List ys))))))

(instance (=> (ToCode elem) (Listable l)
              (Listable (-> elem l)))
  (= list_ acc
    (\ x (list_ (: (toCode x) acc)))))

(:doc "Make a list from given arguments.

This function can take variable number of arguments, but requires
resulting type to be a concrete type.

==== __Examples__

>>> (:: (list \'a \'b \'c) Code)
(a b c)
>>> (:: (list \'a #\'b \"c\" (:: 0xd Int)) Code)
(a #\'b \"c\" 13)
")
(:: list (=> (Listable lst) lst))
(= list (list_ []))


;;; CXR

(:doc "Get first element of list 'Code'.

The function 'car' returns the first element of 'List' and 'HsList'
constructor, or 'nil' value when the 'List' or 'HsList' were empty.
Throws 'FinkelListException' when the given argument was non-list value.

==== __Examples__

>>> (car '(a b c))
a
>>> (car '[a b c])
a
>>> (car nil)
nil
>>> (car 'foo)
*** Exception: Finkel.Core.List.car: non-list value `foo'
")
(:: car (-> Code Code))
(= car (@ whole (LForm (L l code)))
  (case code
    (List (: x _))   x
    (List [])        whole
    (HsList (: x _)) x
    (HsList [])      (LForm (L l (List [])))
    _                (error-non-list "car" whole)))
%p(INLINABLE car)

(:doc "Get list without the first element.

The function 'cdr' returns list value without the first element of
'List' or 'HsList' argument. When the argument is a 'HsList', returned
value is converted to a 'List'. Like 'car', throws 'FinkelListException'
when the argument were non-list value.

==== __Examples__

>>> (cdr '(a b c))
(b c)
>>> (cdr '[a b c])
(b c)
>>> (cdr nil)
nil
>>> (cdr 'foo)
*** Exception: Finkel.Core.List.cdr: non-list value `foo'
")
(:: cdr (-> Code Code))
(= cdr (@ whole (LForm (L l code)))
  (let ((= f xs
          (let ((= l' (getLoc (mkLocatedForm xs))))
            (case xs
              [] (LForm (L l' (List [])))
              _  (LForm (L l' (List xs)))))))
    (case code
      (List (: _ xs))   (f xs)
      (List [])         (LForm (L l (List [])))
      (HsList (: _ xs)) (f xs)
      (HsList [])       (LForm (L l (List [])))
      _                 (error-non-list "cdr" whole))))
%p(INLINABLE cdr)

(:doc$ cxr "Rest of /cxr/ functions are composed from 'car' and 'cdr'.

E.g., definition of 'cadr' is:

> (cadr x) == (car (cdr x))

and the definition of 'cdadr' is:

> (cdadr x) == (cdr (car (cdr x)))
")

(:eval-when-compile
  (:: ads [String])
  (= ads
    (let ((= f (concatMap (\ x [(: #'a x) (: #'d x)]))))
      (concat (take 3 (tail (iterate f [[#'a] [#'d]]))))))

  (:: cxr-name (-> String Code))
  (= cxr-name x
    (qSymbol (concat ["c" x "r"])))

  (:: doc (-> String Code))
  (= doc xs
    (let ((= f x (++ "`c" [x] "r'"))
          (= g ys (unwords (intersperse "of" (map f ys)))))
      (toCode (++ "Get the " (g xs) "."))))

  (:: cxr (-> String [Code]))
  (= cxr xs
    (let ((= name (cxr-name xs))
          (= docstr (doc xs)))
      (case xs
        (: hd tl) [`(:doc ,docstr)
                   `(:: ,name (-> Code Code))
                   `(= ,name (. ,(cxr-name [hd]) ,(cxr-name tl)))
                   `%p(INLINABLE ,name)]
        _ (throw (FinkelException (++ "cxr: invalid arg: " xs))))))

  (:: cxrs Macro)
  (= cxrs (Macro (\ _ (return `(:begin ,@(concatMap cxr ads)))))))

(cxrs)


;;; List and HsList functions

(:doc "Auxiliary function for higher order function.

Make a function taking `SrcSpan' and a list of `Code' from given arguments.")
(:: make-list-fn (-> String (-> SrcSpan [Code] a) Code a))
(= make-list-fn label f (@ orig (LForm (L l form)))
  (case form
    (List xs) (f l xs)
    (HsList xs) (f l xs)
    _ (error-non-list label orig)))
%p(INLINE make-list-fn)

(:doc "Like `foldr', but for `Code'.

==== __Examples__

>>> (reduce cons nil '(a b c))
(a b c)
>>> (reduce (\\ x acc (cons `(x is ,x) acc)) nil '(a b c))
((x is a) (x is b) (x is c))
>>> (reduce + 0 '(1 2 3 4 5))
15
>>> (reduce cons nil 'foo)
*** Exception: Finkel.Core.List.reduce: non-list value `foo'
")
(:: reduce (-> (-> Code a a) a Code a))
(= reduce f z
  (make-list-fn "reduce" (\ _ (foldr f z))))

(:doc "Like `foldr1', but for `Code'.

Throws an exception if the second argument was not a list.

==== __Examples__

>>> (reduce1 cons '(a b c))
(a b c)
>>> (reduce1 (\\ x acc (cons `(x is ,x) acc)) '(a b c))
((x is a) (x is b) c)
>>> (reduce1 cons 'foo)
*** Exception: Finkel.Core.List.reduce1: non-list value `foo'
")
(:: reduce1 (-> (-> Code Code Code) Code Code))
(= reduce1 f
  (make-list-fn "reduce1" (\ _ (foldr1 f))))

(:doc "Like `map', but for `Code'.

Apply given function to immediate elements of `List' and
`HsList'. When the second argument was `HsList', the resulting value
converted to 'List'.

==== __Examples__

>>> (mapcar (\\ x `(x is ,x)) '(a b c))
((x is a) (x is b) (x is c))
>>> (mapcar (const nil) 'foo)
*** Exception: Finkel.Core.List.mapcar: non-list value `foo'
")
(:: mapcar (-> (-> Code Code) Code Code))
(= mapcar f
  (make-list-fn "mapcar" (\ l xs (LForm (L l (List (map f xs)))))))

(:doc "Like `filter', but for `Code'.

Filter out immediate element of `List' if the test result is `False'.

==== __Examples__

>>> (keep (/= 'a) '(a b r a c a d a b r a))
(b r c d b r)
>>> (keep (/= 'a) 'foo)
*** Exception: Finkel.Core.List.keep: non-list value `foo'
")
(:: keep (-> (-> Code Bool) Code Code))
(= keep test
  (make-list-fn "keep" (\ l xs (LForm (L l (List (filter test xs)))))))

(:doc "Like `reverse', but for `Code'.

Reverse the given `List' or `HsList'. Other values are kept as-is.

==== __Examples__

>>> (rev '(a b c))
(c b a)
>>> (rev 'foo)
foo
")
(:: rev (-> Code Code))
(= rev (LForm (L l x))
  (LForm (L l (case x
                (List xs) (List (reverse xs))
                (HsList xs) (HsList (reverse xs))
                _ x))))

(:doc "Split `List' and `HsList' to the elements but last and the last element.

==== __Examples__

>>> (unsnoc '(a b c d e))
((a b c d),e)
")
(:: unsnoc (-> Code (, Code Code)))
(= unsnoc form
  (case (rev form)
    mrof (, (rev (cdr mrof)) (car mrof))))
