;;;; Test codes for "building-package.rst".

(defmodule Doc.BuildingPackage
  (export spec)
  (import
   ;; base
   (Control.Exception (bracket))
   (Control.Monad (zipWithM_))
   (Data.List (isPrefixOf sort))
   (System.Exit ((ExitCode ..)))
   (System.Process ((CreateProcess ..) createProcess proc waitForProcess))

   ;; directory
   (System.Directory
    (canonicalizePath doesDirectoryExist doesFileExist getTemporaryDirectory
                      listDirectory removeDirectoryRecursive))

   ;; filepath
   (System.FilePath (</> takeExtension))

   ;; hspec
   (Test.Hspec ((Spec) describe expectationFailure it pendingWith shouldBe))

   ;; Internal
   (Doc.TestAux)))


;;; Spec

(defn (:: spec Spec)
  (describe "building cabal package"
    (it "matches package made with hsfiles template"
      (case-do get-build-tool
        Cabal (pendingWith "not running with cabal-install")
        Stack compare-new-package))))


;;; Auxiliary

(defn (:: compare-new-package (IO ()))
  (bracket make-tmp-dir
           remove-tmp-dir
           compare-package-dirs))

(defn (:: make-tmp-dir (IO (, FilePath String)))
  (fmap (flip (,) "my-new-package") getTemporaryDirectory))

(defn (:: remove-tmp-dir (-> (, FilePath String) (IO ())))
  (. removeDirectoryRecursive (uncurry </>)))

(defn (:: compare-package-dirs (-> (, FilePath String) (IO ())))
  [(, tmpdir pkgname)]
  (case-do (stack-new tmpdir pkgname)
    (Right ExitSuccess) (compare-directory-contents
                         (</> "include" "building-package" pkgname)
                         (</> tmpdir pkgname))
    (Right ec) (expectationFailure (++ "stack new failed with " (show ec)))
    (Left msg) (expectationFailure msg)))

(defn (:: compare-directory-contents (-> FilePath FilePath (IO ())))
  "Recursively compare directory contents."
  [path1 path2]
  (do (<- path1-is-file (doesFileExist path1))
      (<- path2-is-file (doesFileExist path2))
      (if (&& path1-is-file path2-is-file)
          (do (<- contents1 (readFile path1))
              (<- contents2 (readFile path2))
              (shouldBe contents1 contents2))
          (do (<- path1-is-dir (doesDirectoryExist path1))
              (<- path2-is-dir (doesDirectoryExist path2))
              (if (&& path1-is-dir path2-is-dir)
                  (do (<- ls1 (list-directory path1))
                      (<- ls2 (list-directory path2))
                      (let ((= add-dir dir (map (</> dir)))
                            (= ls1' (add-dir path1 ls1))
                            (= ls2' (add-dir path2 ls2))))
                      (zipWithM_ compare-directory-contents ls1' ls2'))
                  (expectationFailure (++ "differed: " path1 ", " path2)))))))

(defn (:: list-directory (-> FilePath (IO [FilePath])))
  "List directory contents, filter outs some ignored files."
  (let ((= ignored path
          (&& (/= ".stack-work" path)
              (/= ".tix" (takeExtension path)))))
    (. (fmap (. sort (filter ignored))) listDirectory)))

(defn (:: stack-new (-> FilePath String (IO (Either String ExitCode))))
  "Run stack new command to generate new package."
  [dir pkgname]
  (do (<- template get-template-path)
      (<- mb-resolver (get-resolver-version pkgname))
      (case mb-resolver
        (Just resolver) (fmap Right
                              (run (Just dir)
                                   "stack" ["--resolver" resolver "--silent"
                                            "new" pkgname
                                            "--omit-packages" template]))
        Nothing (return (Left "Failed to get the resolver version")))))

(defn (:: get-template-path (IO FilePath))
  "Get canonicalized template path."
  ;; XXX: May move template to separate repository to support
  ;; `github:finkel-lang/simple' style template argument.
  ;;
  ;; See: https://docs.haskellstack.org/en/stable/GUIDE/#templates
  ;;
  (canonicalizePath (</> ".." "tool" "finkel.hsfiles")))

(defn (:: get-resolver-version (-> String (IO (Maybe String))))
  "Get stack resolver version from YAML file used in `my-new-package'."
  [pkgname]
  (let ((= yaml-path
          (</> "include" "building-package" pkgname "stack.yaml"))
        (= resolver-line
          (. (concatMap words)
             (filter (isPrefixOf "resolver:"))
             lines)))
    (case-do (fmap resolver-line (readFile yaml-path))
      [_ version] (return (Just version))
      _ (return Nothing))))

(defn (:: run (-> (Maybe String) String [String] (IO ExitCode)))
  "Run command and wait."
  [mb-dir cmd args]
  (do (<- (, _mbin _mbout _mberr ph)
        (createProcess ((proc cmd args) {cwd mb-dir})))
      (waitForProcess ph)))
